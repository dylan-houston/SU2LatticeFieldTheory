import os
import unittest

import numpy as np

from montecarlo import LatticeMarkovChain
from lattice2d import LatticeGaugeTheory2D
from su2matrices import SU2Matrix


class LatticeMarkovChainTest(unittest.TestCase):

    def setUp(self):
        self.lattice = LatticeGaugeTheory2D(random_seed=42)
        self.markovchain = LatticeMarkovChain(self.lattice, seed=42)

    def test_metropolis_test(self):
        # Delta S < 0 always accepted
        for _ in range(0, 10):
            rand = np.random.rand() * -10
            self.assertTrue(self.markovchain._metropolis_test(rand))

        # Delta S should be accepted if S = 0
        self.assertTrue(self.markovchain._metropolis_test(0))

        # Generate a candidate r from a seed, then reset the seed so that the same r is generated by LatticeMetropolis
        np.random.seed(42)
        r = np.random.rand()

        # Since acceptance condition is r < e^{-Delta S}, Delta S < ln(1/r) will give acceptance and
        # Delta S >= ln (1/r) will give rejection
        # Delta_S = 2 * ln(1/r), should give rejection
        np.random.seed(42)
        self.assertFalse(self.markovchain._metropolis_test(2 * np.log(1 / r)))
        # Delta_S = ln(1/r), should give rejection
        np.random.seed(42)
        self.assertFalse(self.markovchain._metropolis_test(np.log(1 / r)))
        # Try Delta_S = 1/2 * ln(1/r), should give acceptance
        np.random.seed(42)
        self.assertTrue(self.markovchain._metropolis_test(1 / 2 * np.log(1 / r)))

    def test_matrix_shift_gives_SU2_matrix(self):
        # generate 100 SU(2) matrices and an update for each
        matrices = np.empty(100, dtype=SU2Matrix)
        for i in range(len(matrices)):
            matrices[i] = SU2Matrix()

        shifted_matrices = np.vectorize(self.markovchain._metropolis_matrix_shift)(matrices)

        for matrix in shifted_matrices:
            self.assertTrue(matrix.is_special_unitary())

    def test_action_is_real_after_site_metropolis_steps(self):
        # perform 100 metropolis steps, so that some will accept and some will reject
        for _ in range(100):
            random_x = np.random.randint(self.lattice.lattice_width())
            random_y = np.random.randint(self.lattice.lattice_height())
            self.markovchain._metropolis_site_step(random_x, random_y)
            action = self.lattice.action()
            self.assertEquals(action, np.real(action))

    def test_each_site_pair_visited(self):
        site_pairs = self.markovchain._generate_random_lattice_step_through_sequence()
        for i in range(self.lattice.lattice_height()):
            for j in range(self.lattice.lattice_width()):
                pair = np.array([i, j])
                self.assertTrue(pair in site_pairs)

        self.assertEqual(self.lattice.lattice_height() * self.lattice.lattice_width(), len(site_pairs))

    def test_markov_chain_index_correct(self):
        self.assertEquals(self.markovchain.get_current_config_index(), 0)
        self.markovchain.run_metropolis(2)
        self.assertEquals(self.markovchain.get_current_config_index(), 2)
        self.markovchain.revert_lattice_to_config(1)
        self.assertEquals(self.markovchain.get_current_config_index(), 1)
        self.markovchain.restore_final_lattice_config()
        self.assertEquals(self.markovchain.get_current_config_index(), 2)

    def test_save_load_mc_configs(self):
        # do not need many configs to check
        self.markovchain.run_metropolis(5, supress_output=True)
        configs = self.markovchain.markov_chain_configs

        self.markovchain.save_configurations_to_file('.tmp_mc_config')
        self.markovchain.load_configurations_from_file('.tmp_mc_config.npy')

        # remove the temporary test file
        os.remove('.tmp_mc_config.npy')

        self.assertTrue(np.array_equal(configs, self.markovchain.markov_chain_configs))
